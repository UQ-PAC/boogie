(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-fun u () Bool)
(declare-fun x () Int)
(declare-fun y () Int)
(declare-fun z () Int)
(declare-fun k () Int)
(push 1)
(set-info :boogie-vc-id |invariant inference check|)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (and (and (not (not (and (= x y) (= y z)))) u) u) (and (=> (not (= (mod k 3) 0)) (not (not (and (= x (+ y 1)) (= (+ y 1) (+ z 1)))))) (=> (= (mod k 3) 0) (not (not (and (= (+ x 1) (+ y 1)) (= (+ y 1) (+ z 1))))))))
))
(check-sat)
(pop 1)
(declare-fun |x'| () Int)
(declare-fun |y'| () Int)
(declare-fun |z'| () Int)
(declare-fun |k'| () Int)
(push 1)
(set-info :boogie-vc-id |invariant inference check|)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (and (and (not (and (not (and (and (= x z) (not (and u (<= 1 (+ k (* 3 (to_int (* (/ 1 3) (to_real (+ (* (- 0 1) k) 2)))))))))) (not (and (not (= y z)) (or (<= 1 (+ y (* (- 0 1) z))) (<= (+ y (* (- 0 1) z)) (- 0 1))))))) (or (and (not (= y z)) (or (<= 1 (+ y (* (- 0 1) z))) (<= (+ y (* (- 0 1) z)) (- 0 1)))) (and (= y z) (not (and (not (and (not (= y z)) (or (<= 1 (+ y (* (- 0 1) z))) (<= (+ y (* (- 0 1) z)) (- 0 1))))) (and (not (<= 1 (+ x (* (- 0 1) y)))) (and (not (<= (+ x (* (- 0 1) y)) (- 0 1))) (and u (not (and (<= 1 (+ k (* 3 (to_int (* (/ 1 3) (to_real (+ (+ (+ (* (- 0 1) k) (* (- 0 1) z)) (* 1 y)) 2))))))) (not (and (= 1 (+ z (* (- 0 1) z))) (not (and (not (= y z)) (or (<= 1 (+ y (* (- 0 1) z))) (<= (+ y (* (- 0 1) z)) (- 0 1)))))))))))))))))) u) u) (and (=> (not (= (mod k 3) 0)) (not (and (not (and (and (= x (+ z 1)) (not (and u (<= 1 (+ (+ (+ x (+ y 1)) (+ z 1)) (* 3 (to_int (* (/ 1 3) (to_real (+ (* (- 0 1) (+ (+ x (+ y 1)) (+ z 1))) 2)))))))))) (not (and (not (= (+ y 1) (+ z 1))) (or (<= 1 (+ (+ y 1) (* (- 0 1) (+ z 1)))) (<= (+ (+ y 1) (* (- 0 1) (+ z 1))) (- 0 1))))))) (or (and (not (= (+ y 1) (+ z 1))) (or (<= 1 (+ (+ y 1) (* (- 0 1) (+ z 1)))) (<= (+ (+ y 1) (* (- 0 1) (+ z 1))) (- 0 1)))) (and (= (+ y 1) (+ z 1)) (not (and (not (and (not (= (+ y 1) (+ z 1))) (or (<= 1 (+ (+ y 1) (* (- 0 1) (+ z 1)))) (<= (+ (+ y 1) (* (- 0 1) (+ z 1))) (- 0 1))))) (and (not (<= 1 (+ x (* (- 0 1) (+ y 1))))) (and (not (<= (+ x (* (- 0 1) (+ y 1))) (- 0 1))) (and u (not (and (<= 1 (+ (+ (+ x (+ y 1)) (+ z 1)) (* 3 (to_int (* (/ 1 3) (to_real (+ (+ (+ (* (- 0 1) (+ (+ x (+ y 1)) (+ z 1))) (* (- 0 1) (+ z 1))) (* 1 (+ y 1))) 2))))))) (not (and (= 1 (+ (+ z 1) (* (- 0 1) (+ z 1)))) (not (and (not (= (+ y 1) (+ z 1))) (or (<= 1 (+ (+ y 1) (* (- 0 1) (+ z 1)))) (<= (+ (+ y 1) (* (- 0 1) (+ z 1))) (- 0 1))))))))))))))))))) (=> (= (mod k 3) 0) (not (and (not (and (and (= (+ x 1) (+ z 1)) (not (and u (<= 1 (+ (+ (+ (+ x 1) (+ y 1)) (+ z 1)) (* 3 (to_int (* (/ 1 3) (to_real (+ (* (- 0 1) (+ (+ (+ x 1) (+ y 1)) (+ z 1))) 2)))))))))) (not (and (not (= (+ y 1) (+ z 1))) (or (<= 1 (+ (+ y 1) (* (- 0 1) (+ z 1)))) (<= (+ (+ y 1) (* (- 0 1) (+ z 1))) (- 0 1))))))) (or (and (not (= (+ y 1) (+ z 1))) (or (<= 1 (+ (+ y 1) (* (- 0 1) (+ z 1)))) (<= (+ (+ y 1) (* (- 0 1) (+ z 1))) (- 0 1)))) (and (= (+ y 1) (+ z 1)) (not (and (not (and (not (= (+ y 1) (+ z 1))) (or (<= 1 (+ (+ y 1) (* (- 0 1) (+ z 1)))) (<= (+ (+ y 1) (* (- 0 1) (+ z 1))) (- 0 1))))) (and (not (<= 1 (+ (+ x 1) (* (- 0 1) (+ y 1))))) (and (not (<= (+ (+ x 1) (* (- 0 1) (+ y 1))) (- 0 1))) (and u (not (and (<= 1 (+ (+ (+ (+ x 1) (+ y 1)) (+ z 1)) (* 3 (to_int (* (/ 1 3) (to_real (+ (+ (+ (* (- 0 1) (+ (+ (+ x 1) (+ y 1)) (+ z 1))) (* (- 0 1) (+ z 1))) (* 1 (+ y 1))) 2))))))) (not (and (= 1 (+ (+ z 1) (* (- 0 1) (+ z 1)))) (not (and (not (= (+ y 1) (+ z 1))) (or (<= 1 (+ (+ y 1) (* (- 0 1) (+ z 1)))) (<= (+ (+ y 1) (* (- 0 1) (+ z 1))) (- 0 1)))))))))))))))))))))
))
(check-sat)
(pop 1)
(push 1)
(set-info :boogie-vc-id |invariant inference check|)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (not (and (not (and (not (and (and (= x z) (not (and u (<= 1 (+ k (* 3 (to_int (* (/ 1 3) (to_real (+ (* (- 0 1) k) 2)))))))))) (not (and (not (= y z)) (or (<= 1 (+ y (* (- 0 1) z))) (<= (+ y (* (- 0 1) z)) (- 0 1))))))) (or (and (not (= y z)) (or (<= 1 (+ y (* (- 0 1) z))) (<= (+ y (* (- 0 1) z)) (- 0 1)))) (and (= y z) (not (and (not (and (not (= y z)) (or (<= 1 (+ y (* (- 0 1) z))) (<= (+ y (* (- 0 1) z)) (- 0 1))))) (and (not (<= 1 (+ x (* (- 0 1) y)))) (and (not (<= (+ x (* (- 0 1) y)) (- 0 1))) (and u (not (and (<= 1 (+ k (* 3 (to_int (* (/ 1 3) (to_real (+ (+ (+ (* (- 0 1) k) (* (- 0 1) z)) (* 1 y)) 2))))))) (not (and (= 1 (+ z (* (- 0 1) z))) (not (and (not (= y z)) (or (<= 1 (+ y (* (- 0 1) z))) (<= (+ y (* (- 0 1) z)) (- 0 1)))))))))))))))))) (not u)))
))
(check-sat)
(pop 1)
